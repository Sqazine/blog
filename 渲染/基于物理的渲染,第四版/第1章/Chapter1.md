# 《基于物理的渲染第四版》第一章(Introduction)

## 1.[介绍](https://pbr-book.org/4ed/Introduction#)

渲染是根据三维场景的描述生成图像的过程.显然,这是一项广泛的任务,有许多方法可以解决. *基于物理* 的技术试图模拟现实;也就是说,它们使用物理原理来模拟光与物质的相互作用.虽然基于物理的方法似乎是最明显的渲染方法,但它只是在过去 15 年左右的时间里才被广泛采用.

本书介绍的pbrt是一种基于光线跟踪算法的物理渲染系统.它能够渲染复杂场景的逼真图像,如图 1.1 所示(除了本章中标注的少数例外情况外,本书中的所有图像都是用pbrt渲染的).

大多数计算机图形学书籍介绍的都是算法和理论,有时还会结合一些代码片段.相比之下,本书将理论与功能完善的渲染系统的完整实现相结合.此外,该系统的完整源代码以开源许可的方式提供,本书的全文可在[pbr-book.org/4ed](https://pbr-book.org/4ed)免费在线获取(截至2023年11月1日).更多信息,包括示例场景和有关pbrt的其他信息,请访问网站[pbrt.org](https://pbrt.org/).

<div align=center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="image.png">
</div>

> 图 1.1:使用pbrt渲染的场景.*Kroken* 场景具有复杂的几何形状,材质和光传输.渲染系统能很好地处理所有这些效果,因此可以渲染出像本图这样逼真的图像.您可以从pbrt网站下载该场景和其他许多场景.*(场景由 Angelo Ferretti 提供)*.

### 1.1 文学编程

Donald Knuth在创建 $T_EX$ 排版系统时,基于一个简单但具有革命性的想法,开发了一种新的编程方法.引用 Knuth 的一句话："让我们改变对程序构建的传统态度:与其想象我们的主要任务是指示计算机做什么,不如让我们集中精力向人类解释我们希望计算机做什么".他将这种方法命名为*文学编程*.本书(包括你现在正在阅读的章节)就是一个长篇的文学程序.这意味着,在阅读本书的过程中,你将读到pbrt渲染系统的完整实现,而不仅仅是对它的高级描述.

文学程序是用一种元语言编写的,这种语言混合了文档格式化语言(如 $T_EX$ 或HTML)和编程语言(如 C++).程序由两个独立的系统处理:一个是 "编织者",将文言文程序转换为适合排版的文档;另一个是 "缠绕者",生成适合编译的源代码.我们的文字编程系统是自创的,但深受Norman Ramsey的noweb系统的影响.

文学编程语言有两个重要特点.首先是散文与源代码混合的能力.这一特点让程序描述与实际源代码处于同等地位,从而鼓励精心设计和文档化.其次,该语言提供了将程序代码以完全不同于编译器输入的顺序呈现给读者的机制.这样,程序就能以合乎逻辑的方式进行描述.每个命名的代码块称为一个*片段(fragment)*,每个片段可以通过名称来引用其他片段. 

举一个简单的例子,假设一个函数InitGlobals()表示初始化程序的所有全局变量:
```cpp
void InitGlobals() {
    nMarbles = 25.7;
    shoeSize = 13;
    dielectric = true;
}
```
尽管这个函数很简短,但如果没有任何上下文,就很难理解.例如,为什么变量 nMarbles 可以使用浮点数值？光看代码,我们就需要搜索整个程序,查看每个变量的声明位置和使用方式,才能理解其目的和法定值的含义.虽然这种系统结构对编译器来说没有问题,但人类读者更愿意看到每个变量的初始化代码单独呈现,靠近声明和使用变量的代码.

文学编程中,我们可以将InitGlobals()替换成如下:  
<a id="Function Definitions"></a>
```cpp
<<Function Definitions>>=
void InitGlobals() {
    <<Initialize Global Variables>> 
}
```

这定义了一个叫\<\<Function Definitions\>\>的片段,其包含一个InitGlobals()函数定义.InitGlobals()函数本身指向另一个片段,\<\<Initialize Global Variables\>\>.由于初始化片段尚未定义,我们对该函数一无所知,只知道它可能包含对全局变量的赋值.(不过,我们可以通过点击它右侧的加号来窥探它的内容；这样做可以展开该片段的所有最终代码).

由于还没有声明任何变量,因此目前只使用片段名称是最合适的抽象层次.当我们在程序的稍后部分引入全局变量 shoeSize 时,我们就可以写出
```cpp
<<Initialize Global Variables>>= 
shoeSize = 13;
```

在这里,我们开始定义\<\<Initialize Global Variables\>\>的内容.当文学程序被编译成源代码时,文学编程系统将在InitGlobals()函数的定义中替换代码 shoeSize = 13;.等号后面的符号表示稍后会在此片段中添加更多代码.单击该符号,您将看到更多代码.

稍后,我们可能会定义另一个全局变量 dielectric,并将其初始化附加到片段中：
```cpp
<<Initialize Global Variables>>+= 
dielectric = true;
```
片段名称后的 += 符号表明我们已添加到先前定义的片段中.此外,该符号还可链接回 \<\<Initialize Global Variables\>\> 已添加代码的位置.

当这三个片段交杂在一起时,就变成了代码
```cpp
void InitGlobals() {
    // Initialize Global Variables
    shoeSize = 13;
    dielectric = true;
}
```
通过这种方法,我们可以将复杂函数分解成逻辑上不同的部分,使其更容易理解.例如,我们可以将一个复杂函数写成一系列片段：
```cpp
<<Function Definitions>>+= 
void complexFunc(int x, int y, double *values) {
    <<Check validity of arguments>> 
    if (x < y) {
        <<Swap x and y>> 
    }
    <<Do precomputation before loop>> 
    <<Loop through and update values array>> 
}
```
同样,每个片段的内容都会在 complexFunc() 中进行内联扩展,以便编译.在文档中,我们可以依次介绍每个片段及其实现.通过这种分解方式,我们可以一次只介绍几行代码,从而更容易理解.这种编程方式的另一个优点是,通过将函数分割成逻辑片段,每个片段都有一个明确的目的,因此每个片段都可以独立编写,验证或读取.一般来说,我们会尽量让每个片段少于 10 行.

从某种意义上说,文学编程系统只是一个增强的宏替换软件包,专门用于重新编排程序源代码.这看起来似乎是微不足道的变化,但事实上,文学编程与其他构建软件系统的方式截然不同.

### 1.2 照片级渲染和光线追踪算法

照片级渲染的目标是对同一个3D场景生成一张与照片难以区分的图片.在描述渲染过程之前,我们必须明白,在这里,*难以区分* 这个词并不准确,因为它涉及到人类观察者,而不同的观察者对同一图像的感知可能不同. 尽管我们将在本书中讨论一些感知问题,但考虑到特定观察者的精确特征是一个困难且尚未完全解决的问题.在大多数情况下,我们满足于准确模拟光的物理特性及其与物质的相互作用,并依靠我们对显示技术的理解,为观众呈现最佳图像.

既然我们一心一意专注于对光的现实模拟,那么我们似乎有必要问一问:*光是什么*?通过光进行感知是我们生存的核心,因此,自有史以来,这个简单的问题就一直困扰着著名的哲学家和物理学家.

古印度的唯识学派(公元前 5-6 世纪)认为,光是沿着光线高速运动的小粒子的集合.公元前5世纪,希腊哲学家Empedocles推测,神火从人眼中喷出,与太阳光线结合产生视觉.18 至 19 世纪期间,Newton、Thomas Young和Augustin-Jean Fresnel等多面手支持相互冲突的理论,将光建模为波或粒子传播的结果.在同一时期,André-Marie Ampère,Joseph-Louis Lagrange,Carl Friedrich Gauß和Michael Faraday对电与磁之间的关系进行了研究,最终James Clerk Maxwell突然将两者戏剧性地统一为一个综合理论,即现在的 *电磁学(electromagnetism)*.

在这一框架中，光是一种波的表现形式：带电粒子(如灯泡灯丝中的电子)的运动会对周围的*电场*产生扰动，并向远离光源的方向传播。电场振荡也会引起磁场的二次振荡，而磁场振荡又会加强电场振荡，如此循环。